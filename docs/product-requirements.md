# **Vibe Runner: Project Plan & Technical Specification**

**Version:** 1.5 **Date:** 2025-11-13

## **0\. Development Cycle (Phased Approach)**

This project will be built in small, manageable phases to ensure stability and focus.

### **Phase 1: Core Local Game (Client-Only)**

* **Goal:** Create a single-player, local-only version of the game.  
* **Tasks:**  
  * Set up the HTML page with a Pixi.js canvas.  
  * Create the `Player` class.  
  * Implement the `gameLoop` (`requestAnimationFrame`).  
  * Implement basic physics: gravity.  
  * Implement player input: "Jump" (e.g., Spacebar) that applies an upward velocity.  
  * Create a `Ground` object and basic collision detection (player vs. ground).  
  * Create a simple `Obstacle` class and add a few static obstacles to the screen.  
  * Implement player vs. obstacle collision detection (AABB).  
  * Implement a simple "death" state (e.g., game loop stops).  
* **Assets Required (Placeholders):**  
  * **`player-static.svg`**: A static, non-animated sprite for the player.  
  * **`ground-tile.svg`**: A tileable graphic for the ground platform.  
  * **`obstacle-firewall.svg`**: A simple, static obstacle.  
  * **`font-debug.woff2`**: A basic monospaced font to display score/debug info.  
  * *Note: All assets in this phase are functional placeholders. Refer to `Section 3. Art Style & Aesthetics` for visual guidance.*

  ### **Phase 2: Basic Server & Client Connection**

* **Goal:** Connect a single client to the Go server and control the player's *existence* from the server.  
* **Tasks:**  
  * Set up the Go server with `gorilla/websocket`.  
  * Implement the WebSocket connection handshake.  
  * On client connect (`{"e": "join", ...}`), the server will spawn a "player" in its internal state.  
  * Implement the server's `gameTicker` (e.g., 20Hz).  
  * The server's game state (containing the single player's position) is broadcast to the client (`{"e": "state", ...}`).  
  * The client's player sprite is *driven* by the server's state broadcast (i.e., client-side prediction is *off* for now).  
* **Assets Required:**  
  * *No new visual assets are required for this phase.*

  ### **Phase 3: Client-Side Prediction & Multiplayer Ghosts**

* **Goal:** Re-enable client-side responsiveness and add "ghost" players.  
* **Tasks:**  
  * Implement **Client-Side Prediction**:  
    * Client jumps *immediately* on input.  
    * Client sends `{"e": "jump", ...}` to the server.  
    * Server validates the jump and includes it in the *next* state broadcast.  
    * Client implements basic state correction/snapping if its predicted position desyncs from the server's broadcasted position.  
  * Implement **Multiplayer Ghosts**:  
    * Allow multiple clients to connect.  
    * The server's `state` broadcast now includes *all* players.  
    * The client renders all other players as "ghost" sprites.  
    * Implement **Entity Interpolation (lerp)** on ghosts so their 20Hz movement looks smooth.  
* **Assets Required:**  
  * **`player-ghost.svg` / Shader**: A "ghost" version of the player sprite, or a GLSL shader to create the silhouette/glitch effect described in `3.3`.  
  * **`font-player-name.woff2`**: The chosen 80s-style font (e.g., "VT323") for rendering player names above ghosts.  
  * *Note: Refer to `Section 3.3. Characters` for the specific "ghost" visual description.*

  ### **Phase 4: Deterministic Procedural Generation**

* **Goal:** Create the "infinite" level, generated by the server and sent to clients.  
* **Tasks:**  
  * Implement the **Seeded PRNG** logic on the server.  
  * Implement the **Level Chunk** generation logic (e.g., `generateChunk(seed)`).  
  * Define the `{"e": "chunk", ...}` network message.  
  * The server now generates chunks ahead of the players and broadcasts them.  
  * The server's collision detection now uses the procedurally generated obstacle data.  
  * The client receives chunk data and renders the obstacles.  
* **Assets Required:**  
  * **Obstacle Library (SVG/PNG):**  
    * `obstacle-glitch-tall.svg` (A tall, thin "firewall").  
    * `obstacle-glitch-low.svg` (A low, wide "data-block").  
    * `obstacle-glitch-spike.svg` (A small "glitch" to jump over).  
  * **Collectible Library (SVG/PNG):**  
    * `collectible-snippet-01.svg` (e.g., glowing `<blink>`).  
    * `collectible-snippet-02.svg` (e.g., glowing `goto 10;`).  
  * *Note: This phase requires a small library of assets for the PRNG to choose from. Refer to `Section 3.5` for visual style.*

  ### **Phase 5: The Full Game Loop**

* **Goal:** Implement the complete player experience from start to finish.  
* **Tasks:**  
  * Create the **Main Menu / Splash Screen** (HTML/CSS).  
  * Implement the "Join Game" flow (enter name, click "RUN", connect WebSocket).  
  * Implement the **Death & Respawn Cycle**:  
    * Server detects player death and sends `{"e": "death", ...}`.  
    * Client receives death message, stops the game, and shows a "Game Over" UI.  
    * Client's "RUN AGAIN" button disconnects and reconnects (or sends a new "join" message).  
  * Implement the **Leaderboard**:  
    * Connect Go server to **Redis**.  
    * On death, write `(score, name)` to the Redis Sorted Set.  
    * Create a new server endpoint (or message) for clients to fetch the Top 10 from Redis.  
    * Display the leaderboard in the client UI.  
* **Assets Required:**  
  * **`logo-viberunner.svg`**: The main game title/logo for the splash screen.  
  * **UI Assets (HTML/CSS/SVG):**  
    * `ui-frame.svg` (A 9-slice "terminal" frame for UI boxes).  
    * `ui-button-run.svg` (The main "RUN" button).  
    * `ui-button-reboot.svg` (The "RUN AGAIN" / "REBOOT" button).  
    * `ui-text-input.css` (Styling for the "Enter Name" box to match the theme).  
    * `ui-fatal-error-text.svg` (Optional: The `FATAL ERROR` death message as a graphic).  
  * *Note: This phase builds the complete UI shell. Refer to `Section 3.6. UI & HUD` for the "80s Computer Terminal" aesthetic.*

  ### **Phase 6: Polish & Tooling**

* **Goal:** Add final aesthetics, audio, and developer tools.  
* **Tasks:**  
  * Implement the 80s Sci-Fi theme: parallax backgrounds, phosphor UI, etc.  
  * Integrate the provided `wav/mp3` soundtrack.  
  * Implement the **Developer Debug HUD** (`?debug=true`) to show hitboxes and ping.  
  * Create the **Load Testing Script** (Go/Python) to simulate 500+ users.  
  * Create the basic **Admin Panel** to view server stats.  
* **Assets Required:**  
  * **Player Animation (Spritesheets):**  
    * `player-run-spritesheet.png` (Full multi-frame run cycle).  
    * `player-jump-spritesheet.png` (Sprites for jump, peak, and fall).  
    * `player-die-effect.png` (Spritesheet for the "glitch-out" death animation).  
  * **Parallax Backgrounds (High-res PNGs):**  
    * `bg-layer-01-sky.png` (Farthest layer: Sky, OutRun sun).  
    * `bg-layer-02-skyline.png` (Silhouette city).  
    * `bg-layer-03-midground.png` (Floating chrome shapes).  
    * `bg-layer-04-foreground.png` (Scrolling server racks).  
  * **Audio (User-provided):**  
    * `soundtrack-loop.mp3`  
    * `sfx-jump.wav`  
    * `sfx-die.wav`  
    * `sfx-collect.wav`  
  * **Effects & Shaders (GLSL / PNG):**  
    * `shader-scanlines.glsl` (GLSL code for the UI/screen overlay).  
    * `shader-bloom.glsl` (GLSL code for the neon glow).  
    * `particle-trail.png` (Texture for the player's neon foot trail).  
  * *Note: This is the "make it pretty" phase. Refer to `Section 3. Art Style & Aesthetics` for all visual and atmospheric details.*

  ## **1\. User Stories**

  ### **1.1. Epic: Onboarding & Main Menu**

* **As a first-time player,** I want to see a splash screen with the game's title so I know I'm in the right place.  
* **As a player,** I want to enter a nickname for myself so I can be identified on the leaderboard and by other players.  
* **As a player,** I want to click a "RUN" button to immediately join the game.

  ### **1.2. Epic: Core Gameplay**

* **As a player,** I want to control my character with a single "jump" action so I can avoid obstacles.  
* **As a player,** I want to instantly die and and see a "death" effect when I collide with a "firewall" or "glitch."  
* **As a player who just died,** I want to see my final score and an option to "RUN AGAIN" immediately.

  ### **1.3. Epic: Multiplayer & Social**

* **As a player,** I want to see other players' "shadow" sprites running the same track as me, with their names above them.  
* **As a player,** I want to see a real-time leaderboard of the top players in my session.

  ### **1.4. Epic: Developer & Admin**

* **As a developer,** I want a debug mode so I can visually confirm collision boxes and network latency.  
* **As a developer,** I want to run a load test script to ensure the server can handle 500+ concurrent players before deployment.  
* **As an admin,** I want to view a dashboard to see how many players are currently connected.

  ## **2\. Product Requirements Document (PRD)**

  ### **2.1. Game Overview**

* **Product Name:** Vibe Runner  
* **Concept:** An always-on, massively multiplayer 2D infinite runner. All players run the exact same procedurally generated level simultaneously.  
* **Theme:** **80s Sci-Fi & Computer Aesthetic.** A blend of dark, synthwave-infused sci-fi (parallaxing neon cityscapes, distant nebulae) with 80s computer UI elements (glowing phosphor text, scan lines, `[ACCESSING...]` motifs). Player sprites are pixelated, but the overall presentation is modern and high-res.  
* **Target Audience:** Players looking for a quick, skill-based challenge; fans of retro-games and the synthwave aesthetic; players who enjoy social, "shared-moment" gaming.  
* **Core Loop:**  
  1. **Splash Screen:** Player visits the URL and sees a main menu.  
  2. **Join:** Player enters a name, clicks "RUN", and connects.  
  3. **Spawn:** Player character instantly spawns into the live, in-progress game.  
  4. **Survive:** Player character runs automatically. The player uses a single action (**Jump**) to dodge procedurally generated obstacles (themed as "glitches" or "firewalls").  
  5. **Die:** Hitting an obstacle results in instant death.  
  6. **Rank:** The player's "Time Survived" is their score. A real-time leaderboard shows the top survivors.  
  7. **Respawn:** Player is returned to a "Game Over" screen (showing their score) with a "RUN AGAIN" button.

  ### **2.2. Core Features (MVP)**

|  | Feature | Description |
| ----- | ----- | ----- |
|  | **Main Menu / Splash Screen** | A static entry screen with the game title. Includes a text input for "Player Name" and a "RUN" button to join the game. |
|  | **Player Controller** | Single-button **Jump** mechanic. Physics are tight, responsive, and deterministic. |
|  | **Infinite Level** | The level is **deterministically, procedurally generated** by the server. Every player receives the *exact same* sequence of obstacles at the *exact same time*. |
|  | **Massive Multiplayer** | Players see all other active players as "shadow" sprites with their names rendered above. Players pass through each other. |
|  | **Real-Time Leaderboard** | An on-screen UI element shows the Top 10 players ranked by "Time Survived" for the current session. |
|  | **Aesthetics & Audio** | 80s sci-fi theme with parallax scrolling backgrounds. UI elements have a CRT/phosphor-glow look. The provided `wav/mp3` soundtrack will be the core audio. |
|  | **Death & Respawn Cycle** | On death, the player is shown their final score and a "RUN AGAIN" button to instantly respawn. |

  ### **2.3. Developer & QA Tooling**

| Feature | Description |
| ----- | ----- |
| **Debug HUD** | A client-side toggle (e.g., via a hotkey or URL query `?debug=true`) that overlays **collision boxes**, **network ping**, and server vs. client state. |
| **Admin Panel** | A simple, separate web-based dashboard for viewing server health, **current player count**, and server logs in real-time. |
| **Load Testing Script** | A script (e.g., in Go or Python) that can **simulate 500+ concurrent WebSocket clients** to stress-test the backend server and measure performance. |

  ## **3\. Art Style & Aesthetics**

This section defines the complete visual identity. The goal is a **"Hyper-Synthwave"** look: a self-aware, over-the-top, and technically modern interpretation of the 80s' vision of the future. It should be fun, absurdly vibrant, and drenched in neon.

**Key References:** *Far Cry 3: Blood Dragon* (for its satirical 80s tone), *Katana ZERO* / *Hyper Light Drifter* (for modern "hi-bit" pixel art and lighting), *Hotline Miami* (for its color palette and grit), *Alien: Isolation* (for its CRT computer UI).

### **3.1. Core Principles**

* **Go Over The Top:** More bloom, more glow, more parallax, more neon. If it feels subtle, it's not enough.  
* **Modern Techniques:** This is not a "retro" game. We use high-resolution rendering, smooth animations, WebGL shaders, and particle effects to create a *modern* game that *looks* like an 80s dream.  
* **Contrast:** The world is built on a foundation of dark, deep colors (midnight blue, dark purple) to make the explosive neon highlights (cyan, pink, orange) "pop."

  ### **3.2. Color Palette**

* **Base:** Deep Indigo (`#1a1a2e`), Dark Purple (`#301a4b`), Near-Black.  
* **Primary Neon:** Electric Pink (`#ff007f`), Hyper-Cyan (`#00f0ff`).  
* **Secondary Neon:** Solar Orange (`#ff8c00`), Phosphor Green (`#33ff00` \- UI only).  
* **Obstacle Color:** Glitch Red (`#ff003c`).

  ### **3.3. Characters**

* **Player Sprite:**  
  * **Style:** Detailed "hi-bit" pixel art, designed for fluid animation (Phase 6).  
  * **Visuals:** A "data-runner" with a dark suit (`#301a4b`) and glowing `Hyper-Cyan` trace lines.  
  * **Key Feature:** An absurdly oversized, glowing **Electric Pink** visor.  
  * **Fun Detail:** A comically large 80s hairstyle (e.g., mullet, big perm) that flows dramatically behind them as they run.  
* **Ghost Sprites (Other Players):**  
  * **Visuals:** A pure black silhouette of the player sprite.  
  * **Effect:** The silhouette has a bright, 1px neon outline (player's chosen color, e.g., orange).  
  * **Glitch Effect:** The ghost should have a subtle "VHS tracking" shader applied, making it flicker and occasionally have horizontal static lines pass through it, as if it's a "poor recording" of another player.

  ### **3.4. Environment & Background**

The background is high-resolution and uses aggressive **parallax scrolling** to create a sense of depth and speed.

* **Layer 1 (Farthest):** A deep purple sky with a *massive*, low-hanging **OutRun-style sun** (a magenta circle with horizontal scan lines) setting.  
* **Layer 2 (Skyline):** A dark silhouette of a futuristic, 80s-style metropolis. Thousands of tiny windows glow in pink and cyan.  
* **Layer 3 (Midground):** Giant, chrome-reflective geometric shapes (pyramids, spheres) that slowly float by, reflecting the scene's neon lights. Think 80s CGI art.  
* **Layer 4 (Foreground):** Large, detailed pixel-art structures that scroll by, such as the side of a massive, dark server rack with thousands of randomly blinking LEDs.  
* **Layer 5 (Ground):** The `ground-tile` platform. A dark, near-black surface with a sharp, glowing `Hyper-Cyan` top edge. This edge should cast a bloom/glow effect onto the player's feet.

  ### **3.5. Obstacles & Collectibles**

* **Obstacles ("Firewalls"):**  
  * **Style:** "Digital Glitch" aesthetic.  
  * **Visuals:** Not just a red block. It's a `Glitch Red` rectangle, but it constantly flickers, has chromatic aberration at its edges, and has "pixel-sorting" artifacts that drip down from it. Reference the glitch effects in *Katana ZERO*.  
* **Collectibles ("Code Snippets"):**  
  * **Style:** Self-aware and fun.  
  * **Visuals:** Floating, glowing, monospaced text.  
  * **Examples:** `<blink>`, `goto 10;`, `// TODO: fix this`, `[object Object]`.

  ### **3.6. UI & HUD**

* **Style:** "80s Computer Terminal."  
* **Reference:** The UI from *Alien: Isolation* or *Fallout*'s terminals.  
* **Font:** A glowing, monospaced pixel font (like "VT323" or "Press Start 2P" from Google Fonts). All text is `Phosphor Green`.  
* **Containers:** All UI elements (leaderboard, score) are in dark, 70% transparent black boxes with sharp, 1px `Hyper-Cyan` borders.  
* **Effects:** The entire UI (and optionally the whole screen) has a very subtle, gently flickering **scan line** overlay shader.  
* **Fun Detail:**  
  * **Main Menu:** Shows `[SYSTEM BOOTING...]` and `[ACCESSING VIBE_GRID...]`.  
  * **Death Screen:** Instead of "Game Over," it displays a fake system crash: `FATAL ERROR: 0xDEADBEEF` `PLAYER_PROCESS_TERMINATED` `[Press 'R' to REBOOT]`

  ## **4\. Deep-Dive Technical Architecture**

  ### **4.1. Frontend (Client): Pixi.js**

* **Engine:** **Pixi.js** for 2D WebGL rendering. We will write our own simple, deterministic physics (Gravity, Jump Force) for maximum control.  
  * **Game Loop:** The core loop will be driven by `requestAnimationFrame`.  
    let lastTime \= 0;  
  * function gameLoop(currentTime) {  
  *   const deltaTime \= (currentTime \- lastTime) / 1000; // in seconds  
  *   
  *   update(deltaTime); // Run game logic (physics, input)  
  *   render(deltaTime); // Draw everything  
  *   
  *   lastTime \= currentTime;  
  *   requestAnimationFrame(gameLoop);  
  * }  
*   
* **Client-Side Prediction:** To feel "instant," the player's jump happens *immediately* on input, *before* the server confirms it.  
  * User presses "Spacebar".  
  * `onInput()`: The client's `Player` object *immediately* gets a `velocityY` applied.  
  * `network.send({"e": "jump", "d": {"t": Date.now()}})`: A "jump" event is sent to the server with a timestamp.  
  * The client continues to simulate its own movement.  
  * If a "correction" packet arrives from the server (e.g., `{"e": "correction", "d": {"x": 100, "y": 50}}`), the client will *snap* the player's position.  
* **Entity Interpolation (For "Ghosts"):** To prevent jittery movement, we *smooth* other players' movements.  
  * Each "ghost" sprite will have a `lastPosition` and a `targetPosition`.  
  * When a state packet arrives, we update the `targetPosition`.  
  * In our `render(deltaTime)` loop, we **linearly interpolate (lerp)** the ghost's *visual* position:  
  * // Example LERP function  
  * function lerp(start, end, amount) {  
  *   return (1 \- amount) \* start \+ amount \* end;  
  * }  
  *   
  * // In the render loop:  
  * ghost.visual\_x \= lerp(ghost.visual\_x, ghost.targetPosition.x, 0.3);  
* 

  ### **4.2. Backend (Server): Go (Golang)**

* **Technology:** Go, using the `gorilla/websocket` library for handling connections.  
* **Concurrency Model:** One **Goroutine** will be spawned for *each* connected player to read their incoming messages (`readPump`). A single, central **Goroutine** (`gameTicker`) will run the main game loop, collect all inputs, and broadcast the game state.  
  * **Server Game Loop (The "Tick"):** This is the heartbeat of the entire game.  
    // Run the main game loop at 20Hz  
  * ticker := time.NewTicker(50 \* time.Millisecond)  
*   
  1. In each tick, the server does this, *in order*:  
     1. **Process Inputs:** Collect all buffered `jump` messages from all players.  
     2. **Run Simulation:** Update the game state.  
        * Move every *alive* player forward.  
        * Apply physics (gravity, jump velocity from inputs).  
        * Run **collision detection** for *all* players against the level.  
        * If `collision == true`, set `player.isAlive = false` and send a *targeted* death message: `S->C: {"e": "death", "d": {"s": 5000}}`.  
     3. **Broadcast State:** Bundle all *living* player positions into one large message and broadcast it to *all* connected clients. `S->C: {"e": "state", "d": {...}}`.  
* **Deterministic Procedural Generation:** This ensures every player gets the same level.  
  1. **Master Seed:** On server start, generate a `masterSeed = "vibe-runner-12345"`.  
  2. **Level Chunks:** The level is generated in "chunks" (e.g., 5 screens wide).  
  3. **Seeded PRNG:** To generate Chunk `N`, the server initializes a **Pseudo-Random Number Generator (PRNG)** with a *deterministic* seed: `seed_N = hash(masterSeed + N)`.  
  4. The server uses this `prng_N` to generate all obstacles for that chunk.  
  5. The server broadcasts the obstacle data (`{"e": "chunk", ...}`) to clients *before* they reach it.

  ### **4.3. Network Protocol: WebSockets (JSON)**

Messages will use short keys (e.g., `e` \= event, `d` \= data) to minimize bandwidth.

#### **Client-to-Server (C-\>S)**

* **Join Game:** Sent once after the WebSocket connects. `{"e": "join", "d": {"n": "VibeKing"}}`  
* **Player Input:** Sent every time the player jumps. `{"e": "jump", "d": {"t": 1678886400123}}`

  #### **Server-to-Client (S-\>C)**

* **Welcome / Handshake:** Sent once to a new player. `{"e": "welcome", "d": {"id": 12345, "seed": "vibe-runner-12345", "serverTime": 1678886400500}}`  
  * `id`: The player's unique ID for this session.  
  * `seed`: The level's master seed.  
  * `serverTime`: Used to synchronize the client's clock.  
* **Game State (Broadcast):** Sent to *all* clients at the server's tick rate (e.g., 20Hz). `{"e": "state", "d": {"t": 1678886400550, "p": [{"i": 12345, "x": 1024, "y": 50}, {"i": 12346, "x": 1022, "y": 80}]}}`  
  * `t`: The server **t**imestamp for this state.  
  * `p`: Array of **p**layers.  
  * `i`: player **i**d.  
  * `x`, `y`: player position.  
* **Player Death (Targeted):** Sent *only* to the player who died. `{"e": "death", "d": {"s": 120.5}}`  
  * `s`: Final **s**core (time survived).  
* **Level Data:** Sent to clients as they approach a new, un-generated part of the level. `{"e": "chunk", "d": {"id": 10, "obs": [{"t": 1, "x": 15000}, {"t": 2, "x": 15100}]}}`  
  * `id`: Chunk ID.  
  * `obs`: Array of **obs**tacles.  
  * `t`: **t**ype of obstacle.  
  * `x`: **x**\-position of obstacle.

  ### **4.4. Database Schema**

* **Redis (In-Memory Cache \- for speed):**  
  * **Live Leaderboard:** A **Sorted Set**. Key: `leaderboard:current`.  
    \# Add a player's score  
  * ZADD leaderboard:current 120.5 "VibeKing"  
  *   
  * \# Get top 10 players  
  * ZREVRANGE leaderboard:current 0 9  
  *   
  * **Player Session Data:** A **Hash**. Key: `player:<id>`.  
    HSET player:12345 name "VVibeKing"  
  *   
* **PostgreSQL (Persistent Storage \- for long-term):**  
  * **`scores` table:**  
    CREATE TABLE scores (  
  *   id BIGSERIAL PRIMARY KEY,  
  *   player\_name VARCHAR(30) NOT NULL,  
  *   score FLOAT NOT NULL,  
  *   achieved\_at TIMESTAMPTZ DEFAULT NOW()  
  * );  
  *   
  * **On player death, the server runs:**  
    INSERT INTO scores (player\_name, score) VALUES ($1, $2);  
  * 

  ### **4.5. Developer Tooling Specs**

* **Debug HUD (Client-Side):**  
  * Activated by `?debug=true` URL parameter.  
  * **Collision Boxes:** Use `Pixi.Graphics` to draw rectangles around the player and all obstacles.  
  * **Ping:** Measure time between sending an `{"e": "ping"}` and receiving an `{"e": "pong"}`.  
  * **State Display:** On-screen text: `Server_X: 1024` vs. `Client_X: 1024.5`.  
* **Load Testing Tool (Go/Python):**  
  * A command-line app: `./load-test -c=500 -url=ws://viberunner.com/ws`  
  * Creates 500 WebSocket connections.  
  * Each "bot" sends `{"e": "join"}`.  
  * Each "bot" runs a loop: `time.Sleep(random(1, 5) * time.Second)` then send `{"e": "jump"}`.  
  * Logs connection failures and message latency.

  ### **4.6. Security Specifications**

This section details measures to protect the game's integrity, player data, and server health.

* **4.6.1. Anti-Cheat (Server-Side Authority)**  
  * **Core Principle:** The server is the absolute source of truth. The client *requests* actions; the server *validates* and *executes* them.  
  * **State Validation:** The client's `{"e": "jump"}` message is a *request*. The server's simulation checks if this jump is legal (e.g., is the player on the ground? Is their `jump` action off cooldown?).  
  * **Collision Authority:** All collision detection (player vs. obstacle) is calculated *only* on the server. A client cannot "lie" and say it missed an obstacle.  
  * **Correction:** If a client's local simulation desynchronizes (e.g., due to lag or tampering), the server's next `{"e": "state"}` broadcast will contain the *correct* position. The client *must* snap to the server's authoritative state. If the server detects a collision, it sends a *targeted* `{"e": "death"}` message, which the client must obey.  
  * **Speed Hacking:** Player movement is calculated based on the server's 20Hz tick rate, not client-provided `deltaTime`. This prevents speed hacks.  
* **4.6.2. Input Sanitization (XSS Prevention)**  
  * **Threat:** A user provides a malicious `player_name` in the `{"e": "join"}` message, such as `<script>document.location='http://evil.com'</script>`.  
  * **Defense:**  
    * **On Ingest (Server):** The Go server *must* sanitize all user-provided strings upon receipt. The player\_name field should be stripped of all HTML/script tags.  
    * **On Storage:** Only the sanitized, plain-text name is stored in Redis and PostgreSQL.  
    * **On Broadcast:** The server broadcasts only the sanitized name in the state packets.  
    * **On Render (Client):** The client's rendering logic (Pixi.js) should render names as Pixi.Text objects, which are not parsed as HTML. This provides a second layer of defense.  
* **4.6.3. Network-Layer Security (DDoS & Botting)**  
  * **Encryption:** Use **WSS (WebSocket Secure)** instead of WS. This encrypts all traffic (like TLS for WebSockets) and prevents man-in-the-middle attacks.  
  * **Rate Limiting:** Implement rate limiting at the Go server (or at a load-balancer level):  
    * **Connection Limiting:** Limit the number of WebSocket connection attempts from a single IP address (e.g., 10 attempts per minute).  
    * **Message Limiting:** Limit the number of messages a single client can send (e.g., 100 messages per second) to prevent malicious message spam.  
  * **Bot Prevention (Future):** If automated bots become a problem (e.g., creating thousands of players to lag the server), a simple, non-intrusive CAPTCHA (like hCaptcha or Turnstile) can be added to the Main Menu "RUN" button in a future phase.  
  *   
  * 

